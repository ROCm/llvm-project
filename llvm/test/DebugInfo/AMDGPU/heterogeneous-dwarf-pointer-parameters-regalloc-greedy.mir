# NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py UTC_ARGS: --version 5
# RUN: llc -x mir -O1 -mtriple=amdgcn -mcpu=gfx1100 -start-before=greedy,0 -stop-after=virtregrewriter,2 -verify-machineinstrs < %s | FileCheck %s
--- |
  define void @_QFPadd(ptr %0, ptr %1) #0 !dbg !3 {
      #dbg_declare(ptr %0, !7, !DIExpression(DIOpArg(0, ptr), DIOpDeref(ptr)), !8)
      #dbg_declare(ptr %1, !9, !DIExpression(DIOpArg(0, ptr), DIOpDeref(ptr)), !8)
    %3 = load i32, ptr %0, align 4, !dbg !10
    %4 = load i32, ptr %1, align 4, !dbg !10
    %5 = icmp sle i32 %3, %4, !dbg !10
    %6 = call { i1, i32 } @llvm.amdgcn.if.i32(i1 %5), !dbg !10
    %7 = extractvalue { i1, i32 } %6, 0, !dbg !10
    %8 = extractvalue { i1, i32 } %6, 1, !dbg !10
    br i1 %7, label %15, label %Flow, !dbg !10

  Flow:                                             ; preds = %15, %2
    %9 = call { i1, i32 } @llvm.amdgcn.else.i32.i32(i32 %8)
    %10 = extractvalue { i1, i32 } %9, 0
    %11 = extractvalue { i1, i32 } %9, 1
    br i1 %10, label %12, label %18

  12:                                               ; preds = %Flow
    %13 = load i32, ptr %0, align 4, !dbg !11
    %14 = add i32 %13, 1, !dbg !11
    store i32 %14, ptr %1, align 4, !dbg !11
    br label %18, !dbg !10, !amdgpu.uniform !12

  15:                                               ; preds = %2
    %16 = load i32, ptr %1, align 4, !dbg !13
    %17 = add i32 %16, 1, !dbg !13
    store i32 %17, ptr %1, align 4, !dbg !13
    br label %Flow, !dbg !10, !amdgpu.uniform !12

  18:                                               ; preds = %12, %Flow
    call void @llvm.amdgcn.end.cf.i32(i32 %11)
    ret void, !dbg !14
  }

  ; Function Attrs: nocallback nofree nounwind willreturn
  declare { i1, i32 } @llvm.amdgcn.if.i32(i1) #1

  ; Function Attrs: nocallback nofree nounwind willreturn
  declare { i1, i32 } @llvm.amdgcn.else.i32.i32(i32) #1

  ; Function Attrs: nocallback nofree nounwind willreturn
  declare void @llvm.amdgcn.end.cf.i32(i32) #1

  attributes #0 = { "target-cpu"="gfx1100" }
  attributes #1 = { nocallback nofree nounwind willreturn }

  !llvm.module.flags = !{!0}
  !llvm.dbg.cu = !{!1}

  !0 = !{i32 2, !"Debug Info Version", i32 3}
  !1 = distinct !DICompileUnit(language: DW_LANG_Fortran95, file: !2, producer: "flang", isOptimized: false, runtimeVersion: 0, emissionKind: FullDebug)
  !2 = !DIFile(filename: "target14.f90", directory: "")
  !3 = distinct !DISubprogram(name: "add", linkageName: "_QFPadd", scope: !2, file: !2, line: 16, type: !4, scopeLine: 16, spFlags: DISPFlagDefinition, unit: !1)
  !4 = !DISubroutineType(cc: DW_CC_normal, types: !5)
  !5 = !{null, !6, !6}
  !6 = !DIBasicType(name: "integer", size: 32, encoding: DW_ATE_signed)
  !7 = !DILocalVariable(name: "a", arg: 1, scope: !3, file: !2, line: 17, type: !6)
  !8 = !DILocation(line: 16, column: 7, scope: !3)
  !9 = !DILocalVariable(name: "b", arg: 2, scope: !3, file: !2, line: 17, type: !6)
  !10 = !DILocation(line: 20, column: 7, scope: !3)
  !11 = !DILocation(line: 21, column: 7, scope: !3)
  !12 = !{}
  !13 = !DILocation(line: 23, column: 7, scope: !3)
  !14 = !DILocation(line: 25, column: 7, scope: !3)
...
---
name:            _QFPadd
tracksRegLiveness: true
noPhis:          true
debugInstrRef:   true
registers:
  - { id: 10, class: vgpr_32, preferred-register: '', flags: [  ] }
  - { id: 11, class: vgpr_32, preferred-register: '', flags: [  ] }
  - { id: 12, class: vgpr_32, preferred-register: '', flags: [  ] }
  - { id: 13, class: vgpr_32, preferred-register: '', flags: [  ] }
  - { id: 22, class: sreg_32, preferred-register: '$vcc_lo', flags: [  ] }
liveins:
  - { reg: '$vgpr0', virtual-reg: '%10' }
  - { reg: '$vgpr1', virtual-reg: '%11' }
  - { reg: '$vgpr2', virtual-reg: '%12' }
  - { reg: '$vgpr3', virtual-reg: '%13' }
machineFunctionInfo:
  scratchRSrcReg:  '$private_rsrc_reg'
  frameOffsetReg:  '$sgpr33'
  stackPtrOffsetReg: '$sgpr32'
  sgprForEXECCopy: '$sgpr105'
body:             |
  ; CHECK-LABEL: name: _QFPadd
  ; CHECK: bb.0 (%ir-block.2):
  ; CHECK-NEXT:   successors: %bb.3(0x40000000), %bb.1(0x40000000)
  ; CHECK-NEXT:   liveins: $vgpr0, $vgpr1, $vgpr2, $vgpr3
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   DBG_PHI $vgpr1, 6
  ; CHECK-NEXT:   DBG_PHI $vgpr0, 5
  ; CHECK-NEXT:   DBG_PHI $vgpr3, 3
  ; CHECK-NEXT:   DBG_PHI $vgpr2, 2
  ; CHECK-NEXT:   DBG_INSTR_REF !9, !DIExpression(DIOpArg(0, i32), DIOpArg(1, i32), DIOpComposite(2, ptr), DIOpDeref(ptr)), dbg-instr-ref(2, 0), dbg-instr-ref(3, 0),  debug-location !8
  ; CHECK-NEXT:   DBG_INSTR_REF !7, !DIExpression(DIOpArg(0, i32), DIOpArg(1, i32), DIOpComposite(2, ptr), DIOpDeref(ptr)), dbg-instr-ref(5, 0), dbg-instr-ref(6, 0),  debug-location !8
  ; CHECK-NEXT:   renamable $vgpr4 = FLAT_LOAD_DWORD renamable $vgpr0_vgpr1, 0, 0, implicit $exec, implicit $flat_scr,  debug-location !10 :: (load (s32) from %ir.0)
  ; CHECK-NEXT:   renamable $vgpr5 = FLAT_LOAD_DWORD renamable $vgpr2_vgpr3, 0, 0, implicit $exec, implicit $flat_scr,  debug-location !10 :: (load (s32) from %ir.1)
  ; CHECK-NEXT:   renamable $vcc_lo = V_CMP_LE_I32_e64 killed $vgpr4, killed $vgpr5, implicit $exec,  debug-location !10
  ; CHECK-NEXT:   renamable $sgpr0 = COPY $exec_lo, implicit-def $exec_lo,  debug-location !10
  ; CHECK-NEXT:   renamable $sgpr1 = S_AND_B32 renamable $sgpr0, killed renamable $vcc_lo, implicit-def dead $scc,  debug-location !10
  ; CHECK-NEXT:   renamable $sgpr0 = S_XOR_B32 renamable $sgpr1, killed renamable $sgpr0, implicit-def dead $scc,  debug-location !10
  ; CHECK-NEXT:   $exec_lo = S_MOV_B32_term killed renamable $sgpr1,  debug-location !10
  ; CHECK-NEXT:   S_CBRANCH_EXECZ %bb.1, implicit $exec,  debug-location !10
  ; CHECK-NEXT:   S_BRANCH %bb.3,  debug-location !10
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.1.Flow:
  ; CHECK-NEXT:   successors: %bb.2(0x40000000), %bb.4(0x40000000)
  ; CHECK-NEXT:   liveins: $sgpr0, $vgpr0_vgpr1:0x000000000000000F, $vgpr2_vgpr3:0x000000000000000F
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   renamable $sgpr0 = S_OR_SAVEEXEC_B32 killed renamable $sgpr0, implicit-def $exec, implicit-def $scc, implicit $exec
  ; CHECK-NEXT:   $exec_lo = S_XOR_B32_term $exec_lo, renamable $sgpr0, implicit-def $scc
  ; CHECK-NEXT:   S_CBRANCH_EXECZ %bb.4, implicit $exec
  ; CHECK-NEXT:   S_BRANCH %bb.2
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.2 (%ir-block.12):
  ; CHECK-NEXT:   successors: %bb.4(0x80000000)
  ; CHECK-NEXT:   liveins: $sgpr0, $vgpr0_vgpr1:0x000000000000000F, $vgpr2_vgpr3:0x000000000000000F
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   renamable $vgpr0 = FLAT_LOAD_DWORD killed renamable $vgpr0_vgpr1, 0, 0, implicit $exec, implicit $flat_scr,  debug-location !11 :: (load (s32) from %ir.0)
  ; CHECK-NEXT:   renamable $vgpr0 = V_ADD_U32_e64 1, killed $vgpr0, 0, implicit $exec,  debug-location !11
  ; CHECK-NEXT:   FLAT_STORE_DWORD killed renamable $vgpr2_vgpr3, killed renamable $vgpr0, 0, 0, implicit $exec, implicit $flat_scr,  debug-location !11 :: (store (s32) into %ir.1)
  ; CHECK-NEXT:   S_BRANCH %bb.4,  debug-location !10
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.3 (%ir-block.15):
  ; CHECK-NEXT:   successors: %bb.1(0x80000000)
  ; CHECK-NEXT:   liveins: $sgpr0, $vgpr2_vgpr3:0x000000000000000F
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   renamable $vgpr0 = FLAT_LOAD_DWORD renamable $vgpr2_vgpr3, 0, 0, implicit $exec, implicit $flat_scr,  debug-location !13 :: (load (s32) from %ir.1)
  ; CHECK-NEXT:   renamable $vgpr0 = V_ADD_U32_e64 1, killed $vgpr0, 0, implicit $exec,  debug-location !13
  ; CHECK-NEXT:   FLAT_STORE_DWORD killed renamable $vgpr2_vgpr3, killed renamable $vgpr0, 0, 0, implicit $exec, implicit $flat_scr,  debug-location !13 :: (store (s32) into %ir.1)
  ; CHECK-NEXT:   renamable $vgpr0_vgpr1 = IMPLICIT_DEF
  ; CHECK-NEXT:   renamable $vgpr2_vgpr3 = IMPLICIT_DEF
  ; CHECK-NEXT:   S_BRANCH %bb.1,  debug-location !10
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.4 (%ir-block.18):
  ; CHECK-NEXT:   liveins: $sgpr0
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   $exec_lo = S_OR_B32 $exec_lo, killed renamable $sgpr0, implicit-def $scc
  ; CHECK-NEXT:   SI_RETURN debug-location !14
  bb.0 (%ir-block.2):
    successors: %bb.3(0x40000000), %bb.1(0x40000000)
    liveins: $vgpr0, $vgpr1, $vgpr2, $vgpr3

    DBG_PHI $vgpr1, 6
    DBG_PHI $vgpr0, 5
    DBG_PHI $vgpr3, 3
    DBG_PHI $vgpr2, 2
    undef %40.sub1:vreg_64 = COPY $vgpr3
    %40.sub0:vreg_64 = COPY $vgpr2
    undef %39.sub1:vreg_64 = COPY $vgpr1
    %39.sub0:vreg_64 = COPY $vgpr0
    DBG_INSTR_REF !9, !DIExpression(DIOpArg(0, i32), DIOpArg(1, i32), DIOpComposite(2, ptr), DIOpDeref(ptr)), dbg-instr-ref(2, 0), dbg-instr-ref(3, 0),  debug-location !8
    DBG_INSTR_REF !7, !DIExpression(DIOpArg(0, i32), DIOpArg(1, i32), DIOpComposite(2, ptr), DIOpDeref(ptr)), dbg-instr-ref(5, 0), dbg-instr-ref(6, 0),  debug-location !8
    %18:vgpr_32 = FLAT_LOAD_DWORD %39, 0, 0, implicit $exec, implicit $flat_scr,  debug-location !10 :: (load (s32) from %ir.0)
    %20:vgpr_32 = FLAT_LOAD_DWORD %40, 0, 0, implicit $exec, implicit $flat_scr,  debug-location !10 :: (load (s32) from %ir.1)
    %22:sreg_32 = V_CMP_LE_I32_e64 %18, %20, implicit $exec,  debug-location !10
    %41:sreg_32 = COPY $exec_lo, implicit-def $exec_lo,  debug-location !10
    %42:sreg_32 = S_AND_B32 %41, %22, implicit-def dead $scc,  debug-location !10
    %0:sreg_32 = S_XOR_B32 %42, %41, implicit-def dead $scc,  debug-location !10
    $exec_lo = S_MOV_B32_term %42,  debug-location !10
    S_CBRANCH_EXECZ %bb.1, implicit $exec,  debug-location !10
    S_BRANCH %bb.3,  debug-location !10

  bb.1.Flow:
    successors: %bb.2(0x40000000), %bb.4(0x40000000)

    %1:sreg_32 = S_OR_SAVEEXEC_B32 %0, implicit-def $exec, implicit-def $scc, implicit $exec
    $exec_lo = S_XOR_B32_term $exec_lo, %1, implicit-def $scc
    S_CBRANCH_EXECZ %bb.4, implicit $exec
    S_BRANCH %bb.2

  bb.2 (%ir-block.12):
    successors: %bb.4(0x80000000)

    %26:vgpr_32 = FLAT_LOAD_DWORD %39, 0, 0, implicit $exec, implicit $flat_scr,  debug-location !11 :: (load (s32) from %ir.0)
    %28:vgpr_32 = V_ADD_U32_e64 1, %26, 0, implicit $exec,  debug-location !11
    FLAT_STORE_DWORD %40, %28, 0, 0, implicit $exec, implicit $flat_scr,  debug-location !11 :: (store (s32) into %ir.1)
    S_BRANCH %bb.4,  debug-location !10

  bb.3 (%ir-block.15):
    successors: %bb.1(0x80000000)

    %23:vgpr_32 = FLAT_LOAD_DWORD %40, 0, 0, implicit $exec, implicit $flat_scr,  debug-location !13 :: (load (s32) from %ir.1)
    %25:vgpr_32 = V_ADD_U32_e64 1, %23, 0, implicit $exec,  debug-location !13
    FLAT_STORE_DWORD %40, %25, 0, 0, implicit $exec, implicit $flat_scr,  debug-location !13 :: (store (s32) into %ir.1)
    %39:vreg_64 = IMPLICIT_DEF
    %40:vreg_64 = IMPLICIT_DEF
    S_BRANCH %bb.1,  debug-location !10

  bb.4 (%ir-block.18):
    $exec_lo = S_OR_B32 $exec_lo, %1, implicit-def $scc
    SI_RETURN debug-location !14
...
